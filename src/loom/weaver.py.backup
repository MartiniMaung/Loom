"""
Pattern Weaver - The intelligent engine that finds architectural patterns.
"""
from typing import List, Dict, Any, Optional, Tuple
from .core import Intent, CapabilityType, OSSProject, RelationshipType
from .graph import SemanticGraph


class Pattern:
    """A discovered architectural pattern."""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.components: List[Tuple[OSSProject, str]] = []  # (project, role)
        self.connections: List[Dict[str, Any]] = []
        self.complexity: float = 0.0  # 0-1 scale
        self.confidence: float = 0.0  # 0-1 scale
        self.tags: List[str] = []
        
    def add_component(self, project: OSSProject, role: str):
        """Add a component to the pattern."""
        self.components.append((project, role))
        
    def calculate_metrics(self, graph: SemanticGraph):
        """Calculate pattern metrics."""
        # Complexity based on number of components and relationships
        num_components = len(self.components)
        
        # Count internal connections between components
        internal_connections = 0
        component_names = [comp[0].name for comp in self.components]
        for source in component_names:
            for target in component_names:
                if source != target and graph.graph.has_edge(source, target):
                    internal_connections += 1
        
        self.complexity = min(1.0, (num_components * 0.1) + (internal_connections * 0.05))
        
        # Confidence based on popularity and compatibility
        if self.components:
            # Average popularity
            pop_sum = sum(comp[0].popularity_score for comp in self.components)
            pop_avg = pop_sum / len(self.components)
            
            # Compatibility score
            compat_score = 0.0
            compat_pairs = 0
            for i, (source_comp, _) in enumerate(self.components):
                for j, (target_comp, _) in enumerate(self.components):
                    if i != j:
                        if graph.graph.has_edge(source_comp.name, target_comp.name):
                            edge_data = graph.graph[source_comp.name][target_comp.name]
                            if edge_data.get('relationship_type') == RelationshipType.COMPATIBLE_WITH.value:
                                compat_score += edge_data.get('strength', 0.5)
                                compat_pairs += 1
            
            avg_compat = compat_score / max(1, compat_pairs)
            self.confidence = (pop_avg * 0.7) + (avg_compat * 0.3)
        else:
            self.confidence = 0.0
            
    def to_dict(self, graph: SemanticGraph) -> Dict[str, Any]:
        """Convert pattern to dictionary."""
        self.calculate_metrics(graph)
        return {
            "name": self.name,
            "description": self.description,
            "complexity": round(self.complexity, 3),
            "confidence": round(self.confidence, 3),
            "components": [
                {
                    "name": project.name,
                    "role": role,
                    "capabilities": [c.value for c in project.capabilities],
                    "license": project.license or "Unknown",
                    "popularity": project.popularity_score
                }
                for project, role in self.components
            ],
            "connections": self._get_connections(graph)
        }
        
    def _get_connections(self, graph: SemanticGraph) -> List[Dict[str, Any]]:
        """Get connections between components in this pattern."""
        connections = []
        component_names = [comp[0].name for comp in self.components]
        
        for source_name in component_names:
            for target_name in component_names:
                if source_name != target_name and graph.graph.has_edge(source_name, target_name):
                    edge_data = graph.graph[source_name][target_name]
                    connections.append({
                        "from": source_name,
                        "to": target_name,
                        "type": edge_data.get('relationship_type', 'unknown'),
                        "strength": edge_data.get('strength', 0.5),
                        "evidence": edge_data.get('evidence', '')
                    })
        
        return connections


class PatternWeaver:
    """The engine that weaves OSS capabilities into patterns."""
    
    def __init__(self, graph: SemanticGraph):
        self.graph = graph
        self.patterns: List[Pattern] = []
        
    def weave_for_intent(self, intent: Intent) -> List[Pattern]:
        """Weave patterns based on user intent."""
        self.patterns = []
        
        # Get all projects that match required capabilities
        matching_projects = self._get_matching_projects(intent)
        
        if not matching_projects:
            return self.patterns
            
        # Generate patterns based on capability combinations
        self._generate_capability_patterns(intent, matching_projects)
        
        # Sort patterns by confidence (highest first)
        self.patterns.sort(key=lambda p: p.confidence, reverse=True)
        
        return self.patterns
        
    def _get_matching_projects(self, intent: Intent) -> Dict[CapabilityType, List[OSSProject]]:
        """Get projects matching each required capability."""
        matching = {}
        
        for capability in intent.required_capabilities:
            project_names = self.graph.find_by_capability(capability)
            projects = []
            for name in project_names:
                proj = self.graph.projects.get(name)
                if proj:
                    projects.append(proj)
            
            if projects:
                # Sort by popularity
                projects.sort(key=lambda p: p.popularity_score, reverse=True)
                matching[capability] = projects
                
        return matching
        
    def _generate_capability_patterns(self, intent: Intent, 
                                    matching_projects: Dict[CapabilityType, List[OSSProject]]) -> None:
        """Generate patterns based on capability combinations."""
        
        # Pattern 1: Full Stack Web Application
        if (CapabilityType.WEB_FRAMEWORK in matching_projects and 
            CapabilityType.DATABASE in matching_projects):
            
            web_projs = matching_projects[CapabilityType.WEB_FRAMEWORK]
            db_projs = matching_projects[CapabilityType.DATABASE]
            
            # Try to find FastAPI + PostgreSQL combination
            fastapi = next((p for p in web_projs if p.name == "FastAPI"), None)
            postgres = next((p for p in db_projs if p.name == "PostgreSQL"), None)
            
            if fastapi and postgres:
                pattern = Pattern(
                    name="Full Stack Python API",
                    description="Production-ready web API with PostgreSQL database"
                )
                pattern.add_component(fastapi, "API Framework")
                pattern.add_component(postgres, "Primary Database")
                
                # Add cache if requested
                if CapabilityType.CACHE in matching_projects:
                    cache_projs = matching_projects[CapabilityType.CACHE]
                    redis = next((p for p in cache_projs if p.name == "Redis"), None)
                    if redis:
                        pattern.add_component(redis, "Cache & Session Store")
                
                # Add ORM layer if SQLAlchemy available
                sqlalchemy = next((p for p in db_projs if p.name == "SQLAlchemy"), None)
                if sqlalchemy:
                    pattern.add_component(sqlalchemy, "ORM & Data Layer")
                
                pattern.tags = ["production", "python", "api", "database"]
                self.patterns.append(pattern)
        
        # Pattern 2: AI/ML Serving Pattern
        if (CapabilityType.WEB_FRAMEWORK in matching_projects and 
            CapabilityType.AI_MODEL in matching_projects):
            
            web_projs = matching_projects[CapabilityType.WEB_FRAMEWORK]
            ai_projs = matching_projects[CapabilityType.AI_MODEL]
            
            # FastAPI + TensorFlow/PyTorch
            fastapi = next((p for p in web_projs if p.name == "FastAPI"), None)
            tensorflow = next((p for p in ai_projs if p.name == "TensorFlow"), None)
            pytorch = next((p for p in ai_projs if p.name == "PyTorch"), None)
            
            ai_framework = tensorflow or pytorch
            if fastapi and ai_framework:
                pattern = Pattern(
                    name="ML Model Serving API",
                    description=f"FastAPI serving {ai_framework.name} machine learning models"
                )
                pattern.add_component(fastapi, "Model Serving API")
                pattern.add_component(ai_framework, "ML Framework")
                
                # Add database if available
                if CapabilityType.DATABASE in matching_projects:
                    db_projs = matching_projects[CapabilityType.DATABASE]
                    if db_projs:
                        pattern.add_component(db_projs[0], "Model Metadata Store")
                
                pattern.tags = ["ai", "ml", "serving", "api"]
                self.patterns.append(pattern)
        
        # Pattern 3: Monitoring Stack
        if (CapabilityType.MONITORING in matching_projects and
            CapabilityType.WEB_FRAMEWORK in matching_projects):
            
            monitoring_projs = matching_projects[CapabilityType.MONITORING]
            web_projs = matching_projects[CapabilityType.WEB_FRAMEWORK]
            
            prometheus = next((p for p in monitoring_projs if p.name == "Prometheus"), None)
            grafana = next((p for p in monitoring_projs if p.name == "Grafana"), None)
            
            if prometheus and grafana:
                pattern = Pattern(
                    name="Monitoring & Observability Stack",
                    description="Prometheus for metrics collection with Grafana visualization"
                )
                pattern.add_component(prometheus, "Metrics Collector")
                pattern.add_component(grafana, "Dashboard & Visualization")
                
                # Add application being monitored
                if web_projs:
                    pattern.add_component(web_projs[0], "Monitored Application")
                
                pattern.tags = ["monitoring", "observability", "metrics"]
                self.patterns.append(pattern)
        
        # Pattern 4: Message Queue Pattern
        if (CapabilityType.MESSAGE_QUEUE in matching_projects and
            CapabilityType.WEB_FRAMEWORK in matching_projects):
            
            mq_projs = matching_projects[CapabilityType.MESSAGE_QUEUE]
            web_projs = matching_projects[CapabilityType.WEB_FRAMEWORK]
            
            rabbitmq = next((p for p in mq_projs if p.name == "RabbitMQ"), None)
            kafka = next((p for p in mq_projs if p.name == "Kafka"), None)
            
            mq_system = rabbitmq or kafka or (mq_projs[0] if mq_projs else None)
            
            if mq_system and web_projs:
                pattern_name = "Event-Driven Architecture"
                if mq_system.name == "Kafka":
                    pattern_name = "Stream Processing Architecture"
                
                pattern = Pattern(
                    name=pattern_name,
                    description=f"Event-driven system with {mq_system.name} message queue"
                )
                pattern.add_component(mq_system, "Message Broker")
                pattern.add_component(web_projs[0], "Application Service")
                
                pattern.tags = ["event-driven", "async", "messaging"]
                self.patterns.append(pattern)
        
        # Pattern 5: Data-Intensive Application
        if CapabilityType.DATABASE in matching_projects:
            db_projs = matching_projects[CapabilityType.DATABASE]
            
            # Find the most popular database
            if db_projs:
                best_db = db_projs[0]  # Already sorted by popularity
                
                pattern = Pattern(
                    name="Data-Intensive Application",
                    description=f"Application centered around {best_db.name} database"
                )
                pattern.add_component(best_db, "Data Storage")
                
                # Add web framework if available
                if CapabilityType.WEB_FRAMEWORK in matching_projects:
                    web_projs = matching_projects[CapabilityType.WEB_FRAMEWORK]
                    if web_projs:
                        pattern.add_component(web_projs[0], "Application Interface")
                
                pattern.tags = ["data", "storage", "backend"]
                self.patterns.append(pattern)
        
        # Pattern 6: Minimal Viable Pattern (one component per capability)
        pattern = Pattern(
            name="Minimal Viable Architecture",
            description="Minimal components to satisfy all requirements"
        )
        
        role_map = {
            CapabilityType.WEB_FRAMEWORK: "Application Framework",
            CapabilityType.DATABASE: "Data Storage",
            CapabilityType.CACHE: "Cache Layer",
            CapabilityType.MESSAGE_QUEUE: "Message Queue",
            CapabilityType.AI_MODEL: "AI/ML Framework",
            CapabilityType.AUTHENTICATION: "Authentication",
            CapabilityType.STORAGE: "File Storage",
            CapabilityType.MONITORING: "Monitoring",
        }
        
        for capability, projects in matching_projects.items():
            if projects:
                role = role_map.get(capability, capability.value.replace('_', ' ').title())
                pattern.add_component(projects[0], role)
        
        if pattern.components:  # Only add if we have components
            pattern.tags = ["minimal", "simple", "beginner"]
            self.patterns.append(pattern)
    
    def get_all_patterns(self) -> List[Dict[str, Any]]:
        """Get all discovered patterns as dictionaries."""
        return [p.to_dict(self.graph) for p in self.patterns]
